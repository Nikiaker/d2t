{"id": "2679d860-7e09-4551-bc65-9638cc4bf56a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "6aa4e0b8-dd56-4da7-a7fd-369499eb3601", "generation": 1, "timestamp": 1763410270.4190893, "iteration_found": 6, "metrics": {"runs_successfully": 1.0, "value_score": 0.5035896362961051, "distance_score": 0.19491855933946986, "combined_score": 0.30409696441076084}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.4479930012674103, "distance_score": 0.23910049028188793, "combined_score": 0.2915487974985611}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms.", "user": "# Current Program Information\n- Fitness: 0.2915\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.2915\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: runs_successfully: 1.0000, value_score: 0.4480, distance_score: 0.2391, combined_score: 0.2915\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.2915)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = 0\n    best_y = 0\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        x = best_x + 1\n        y = best_y - 1\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.4480), Performs well on distance_score (0.2391), Performs well on combined_score (0.2915)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simple random search algorithm that often gets stuck in local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = 0\n    best_y = 0\n    best_value = evaluate_function(best_x, best_y)\n\n    for _ in range(iterations):\n        x = best_x + 1\n        y = best_y - 1\n        value = evaluate_function(x, y)\n\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```\n\n**Explanation of Changes**\n\n1. **Simulated Annealing**: The new `search_algorithm` function implements simulated annealing to escape local minima. This involves introducing a temperature parameter that controls the probability of accepting worse solutions. The temperature is cooled down over time, making the algorithm less likely to accept worse solutions as it progresses.\n\n2. **Random Candidate Generation**: Instead of generating new candidate solutions by adding a fixed value to the current best solution, the new algorithm generates random candidate solutions within a range of -1 to 1. This allows the algorithm to explore a wider range of possibilities and reduces the likelihood of getting stuck in local minima.\n\n3. **Bounds Checking**: The algorithm now checks to ensure that the generated candidate solutions are within the specified bounds. This prevents the algorithm from exploring solutions outside the defined search space.\n\n4. **Probability-Based Acceptance**: The algorithm now uses a probability-based approach to determine whether to accept a worse solution. The probability of acceptance is calculated based on the difference between the current best solution and the new candidate solution, as well as the current temperature. This allows the algorithm to balance exploration and exploitation.\n\nThese changes improve the algorithm's ability to find the global minimum by increasing its exploration capabilities and reducing the likelihood of getting stuck in local minima."]}}, "artifacts_json": "{\"stage1_result\": \"Found solution at x=-4.0961, y=-2.6891 with value=-0.5333\", \"distance_to_global\": \"4.1303\", \"solution_quality\": \"Could be improved\"}", "artifact_dir": null, "embedding": null}