{"id": "f7158535-1235-4b8a-bfb5-78c346be315e", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simulated annealing algorithm with adaptive cooling schedule to minimize the complex function.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize the best solution\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n\n    # Initialize the current solution\n    current_x = best_x\n    current_y = best_y\n    current_value = best_value\n\n    # Adaptive cooling schedule\n    initial_temperature = 1.0\n    temperature = initial_temperature\n    cooling_rate = 0.99\n    min_temperature = 0.01\n\n    for _ in range(iterations):\n        # Generate a new solution\n        new_x = current_x + np.random.uniform(-1, 1)\n        new_y = current_y + np.random.uniform(-1, 1)\n\n        # Ensure the new solution is within bounds\n        new_x = max(bounds[0], min(new_x, bounds[1]))\n        new_y = max(bounds[0], min(new_y, bounds[1]))\n\n        # Evaluate the new solution\n        new_value = evaluate_function(new_x, new_y)\n\n        # Calculate the difference in value\n        delta = new_value - current_value\n\n        # If the new solution is better, accept it\n        if delta < 0:\n            current_x, current_y, current_value = new_x, new_y, new_value\n            # Update the best solution if necessary\n            if new_value < best_value:\n                best_x, best_y, best_value = new_x, new_y, new_value\n        else:\n            # If the new solution is not better, accept it with a probability\n            probability = np.exp(-delta / temperature)\n            if np.random.rand() < probability:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n        # Decrease the temperature adaptively\n        if temperature > min_temperature:\n            temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "0bcfd3ea-8aa2-4666-b31c-f77fbbc0213a", "generation": 2, "timestamp": 1763417359.1183121, "iteration_found": 12, "metrics": {"runs_successfully": 1.0, "value_score": 0.749765942695636, "distance_score": 0.2816561337451037, "combined_score": 0.6593798114713492, "reliability_score": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.5035896362961051, "distance_score": 0.19491855933946986, "combined_score": 0.30409696441076084}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms.", "user": "# Current Program Information\n- Fitness: 0.3041\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.4906 \u2192 0.3041. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stage1_result\n```\nFound solution at x=-4.0961, y=-2.6891 with value=-0.5333\n```\n\n### distance_to_global\n```\n4.1303\n```\n\n### solution_quality\n```\nCould be improved\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.8525, distance_score: 0.2487, combined_score: 0.4906, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.8525, distance_score: 0.2487, combined_score: 0.4906, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.8525, distance_score: 0.2487, combined_score: 0.4906, reliability_score: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4906)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.8525), Performs well on distance_score (0.2487), Performs well on combined_score (0.4906), Performs well on reliability_score (1.0000)\n\n### Program 2 (Score: 0.4906)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.8525), Performs well on distance_score (0.2487), Performs well on combined_score (0.4906), Performs well on reliability_score (1.0000)\n\n### Program 3 (Score: 0.4906)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.8525), Performs well on distance_score (0.2487), Performs well on combined_score (0.4906), Performs well on reliability_score (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3041)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simulated annealing algorithm to minimize the complex function.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize the best solution\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n\n    # Initialize the current solution\n    current_x = best_x\n    current_y = best_y\n    current_value = best_value\n\n    # Cooling schedule\n    initial_temperature = 1.0\n    temperature = initial_temperature\n\n    for _ in range(iterations):\n        # Generate a new solution\n        new_x = current_x + np.random.uniform(-1, 1)\n        new_y = current_y + np.random.uniform(-1, 1)\n\n        # Ensure the new solution is within bounds\n        new_x = max(bounds[0], min(new_x, bounds[1]))\n        new_y = max(bounds[0], min(new_y, bounds[1]))\n\n        # Evaluate the new solution\n        new_value = evaluate_function(new_x, new_y)\n\n        # Calculate the difference in value\n        delta = new_value - current_value\n\n        # If the new solution is better, accept it\n        if delta < 0:\n            current_x, current_y, current_value = new_x, new_y, new_value\n            # Update the best solution if necessary\n            if new_value < best_value:\n                best_x, best_y, best_value = new_x, new_y, new_value\n        else:\n            # If the new solution is not better, accept it with a probability\n            probability = np.exp(-delta / temperature)\n            if np.random.rand() < probability:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n        # Decrease the temperature\n        temperature *= 0.99\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n### Program D2 (Score: 0.3041)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4906, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative distance_score approach\n\n### Inspiration 2 (Score: 0.4906, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative distance_score approach\n\n### Inspiration 3 (Score: 0.3041, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n\n    for _ in range(iterations):\n        # Generate new candidate solution\n        x = best_x + np.random.uniform(-1, 1)\n        y = best_y + np.random.uniform(-1, 1)\n\n        # Ensure bounds are respected\n        x = max(bounds[0], min(x, bounds[1]))\n        y = max(bounds[0], min(y, bounds[1]))\n\n        # Evaluate new candidate solution\n        value = evaluate_function(x, y)\n\n        # Calculate probability of accepting worse solution\n        if value < best_value:\n            best_value = value\n            best_x, best_y = x, y\n        else:\n            probability = np.exp((best_value - value) / temperature)\n            if np.random.rand() < probability:\n                best_value = value\n                best_x, best_y = x, y\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative distance_score approach\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simulated annealing algorithm to minimize the complex function.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize the best solution\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n\n    # Initialize the current solution\n    current_x = best_x\n    current_y = best_y\n    current_value = best_value\n\n    # Cooling schedule\n    initial_temperature = 1.0\n    temperature = initial_temperature\n\n    for _ in range(iterations):\n        # Generate a new solution\n        new_x = current_x + np.random.uniform(-1, 1)\n        new_y = current_y + np.random.uniform(-1, 1)\n\n        # Ensure the new solution is within bounds\n        new_x = max(bounds[0], min(new_x, bounds[1]))\n        new_y = max(bounds[0], min(new_y, bounds[1]))\n\n        # Evaluate the new solution\n        new_value = evaluate_function(new_x, new_y)\n\n        # Calculate the difference in value\n        delta = new_value - current_value\n\n        # If the new solution is better, accept it\n        if delta < 0:\n            current_x, current_y, current_value = new_x, new_y, new_value\n            # Update the best solution if necessary\n            if new_value < best_value:\n                best_x, best_y, best_value = new_x, new_y, new_value\n        else:\n            # If the new solution is not better, accept it with a probability\n            probability = np.exp(-delta / temperature)\n            if np.random.rand() < probability:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n        # Decrease the temperature\n        temperature *= 0.99\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    A simulated annealing algorithm with adaptive cooling schedule to minimize the complex function.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Initialize the best solution\n    best_x = np.random.uniform(bounds[0], bounds[1])\n    best_y = np.random.uniform(bounds[0], bounds[1])\n    best_value = evaluate_function(best_x, best_y)\n\n    # Initialize the current solution\n    current_x = best_x\n    current_y = best_y\n    current_value = best_value\n\n    # Adaptive cooling schedule\n    initial_temperature = 1.0\n    temperature = initial_temperature\n    cooling_rate = 0.99\n    min_temperature = 0.01\n\n    for _ in range(iterations):\n        # Generate a new solution\n        new_x = current_x + np.random.uniform(-1, 1)\n        new_y = current_y + np.random.uniform(-1, 1)\n\n        # Ensure the new solution is within bounds\n        new_x = max(bounds[0], min(new_x, bounds[1]))\n        new_y = max(bounds[0], min(new_y, bounds[1]))\n\n        # Evaluate the new solution\n        new_value = evaluate_function(new_x, new_y)\n\n        # Calculate the difference in value\n        delta = new_value - current_value\n\n        # If the new solution is better, accept it\n        if delta < 0:\n            current_x, current_y, current_value = new_x, new_y, new_value\n            # Update the best solution if necessary\n            if new_value < best_value:\n                best_x, best_y, best_value = new_x, new_y, new_value\n        else:\n            # If the new solution is not better, accept it with a probability\n            probability = np.exp(-delta / temperature)\n            if np.random.rand() < probability:\n                current_x, current_y, current_value = new_x, new_y, new_value\n\n        # Decrease the temperature adaptively\n        if temperature > min_temperature:\n            temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n\n```"]}}, "artifacts_json": "{\"stage1_result\": \"Found solution at x=-1.7138, y=0.6658 with value=-1.5184\", \"distance_to_global\": \"0.0157\", \"solution_quality\": \"Distance < 0.5: Very close\", \"convergence_info\": \"Converged in 10 trials with 10 successes\", \"best_position\": \"Final position: x=1.5584, y=2.9622\", \"average_distance_to_global\": \"2.5504\", \"search_efficiency\": \"Success rate: 100.00%\"}", "artifact_dir": null, "embedding": null}