{"id": "7fcd7c4d-cbab-4dd7-9a48-3318b592f45d", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Perform the differential evolution with multiple runs to ensure global minimum\n    results = []\n    for _ in range(10):  # Increased the number of runs to 10\n        result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, maxiter=iterations)\n        results.append(result)\n        x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Return the best result\n    best_result = min(results, key=lambda x: x.fun)\n    return best_result.x[0], best_result.x[1], best_result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "7de3b3a9-1a89-4547-9c96-0fba00d937a9", "generation": 5, "timestamp": 1763418755.4744332, "iteration_found": 86, "metrics": {"runs_successfully": 1.0, "value_score": 0.999685939513552, "distance_score": 0.9995011572026847, "combined_score": 1.499539975376372, "reliability_score": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.999685939513544, "distance_score": 0.9995011047521525, "combined_score": 1.4995399517736265, "reliability_score": 1.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms.", "user": "# Current Program Information\n- Fitness: 1.4995\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 1.4995 \u2192 1.4995. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stage1_result\n```\nFound solution at x=-1.7041, y=0.6775 with value=-1.5187\n```\n\n### distance_to_global\n```\n0.0005\n```\n\n### solution_quality\n```\nDistance < 0.5: Very close\n```\n\n### convergence_info\n```\nConverged in 10 trials with 10 successes\n```\n\n### best_position\n```\nFinal position: x=-1.7041, y=0.6775\n```\n\n### average_distance_to_global\n```\n0.0005\n```\n\n### search_efficiency\n```\nSuccess rate: 100.00%\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [1, 1]\n\n    # Define the population size\n    popsize = 100\n\n    # Perform the differential evolution\n    result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, popsize=popsize, maxiter=iterations)\n\n    # Return the result\n    return result.x[0], result.x[1], result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n### Program 2 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [1, 1]\n\n    # Define the population size\n    popsize = 50\n\n    # Perform the differential evolution\n    result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, popsize=popsize, maxiter=iterations)\n\n    # Return the result\n    return result.x[0], result.x[1], result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n### Program 3 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [1, 1]\n\n    # Define the population size\n    popsize = 100\n\n    # Perform the differential evolution\n    result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, popsize=popsize, maxiter=iterations)\n\n    # Return the result\n    return result.x[0], result.x[1], result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Define the population size\n    popsize = 100\n\n    # Perform the differential evolution\n    result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, popsize=popsize, maxiter=iterations)\n\n    # Return the result\n    return result.x[0], result.x[1], result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n### Program D2 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Perform the differential evolution with multiple runs to ensure global minimum\n    results = []\n    for _ in range(5):\n        result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, maxiter=iterations)\n        results.append(result)\n        x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Return the best result\n    best_result = min(results, key=lambda x: x.fun)\n    return best_result.x[0], best_result.x[1], best_result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 1.2766, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 250  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.995  # Adjusted cooling rate for better convergence\n    mutation_rate = 0.15  # Increased mutation rate for more diverse population\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001 or _ == iterations - 1:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (0.973)\n\n### Inspiration 2 (Score: 1.2734, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (0.971)\n\n### Inspiration 3 (Score: 1.4993, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing and genetic algorithm to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 100\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.argmin(values)\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                offspring[i] = (parent1 + parent2) / 2\n\n        # Mutate\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.uniform(-1, 1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Select best\n        idx = np.argmin(values)\n        if values[idx] < best_value:\n            best_value = values[idx]\n            best_x, best_y = offspring[idx]\n\n        # Replace population\n        population = offspring\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Excellent runs_successfully (1.000), Excellent value_score (1.000), Excellent distance_score (0.999)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Perform the differential evolution with multiple runs to ensure global minimum\n    results = []\n    for _ in range(5):\n        result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, maxiter=iterations)\n        results.append(result)\n        x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Return the best result\n    best_result = min(results, key=lambda x: x.fun)\n    return best_result.x[0], best_result.x[1], best_result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nfrom scipy.optimize import differential_evolution\n\n\ndef search_algorithm(iterations=1000, bounds=[(-5, 5), (-5, 5)]):\n    \"\"\"\n    An improved global optimization algorithm using differential evolution to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Define the initial guess\n    x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Perform the differential evolution with multiple runs to ensure global minimum\n    results = []\n    for _ in range(10):  # Increased the number of runs to 10\n        result = differential_evolution(evaluate_function, bounds, x0=x0, polish=True, maxiter=iterations)\n        results.append(result)\n        x0 = [np.random.uniform(bounds[0][0], bounds[0][1]), np.random.uniform(bounds[1][0], bounds[1][1])]\n\n    # Return the best result\n    best_result = min(results, key=lambda x: x.fun)\n    return best_result.x[0], best_result.x[1], best_result.fun\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(point):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    x, y = point\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\nIn the rewritten program, I made the following changes to improve the FITNESS SCORE:\n\n1. **Increased the number of runs**: I increased the number of runs in the `search_algorithm` function from 5 to 10. This allows the algorithm to explore more of the search space and increases the chances of finding the global minimum.\n\n2. **Maintained the same inputs and outputs**: The rewritten program maintains the same inputs and outputs as the original program, but with an improved internal implementation.\n\n3. **Improved the exploration of the search space**: By increasing the number of runs, the algorithm is able to explore more of the search space, which can help to improve the FITNESS SCORE.\n\nNote that the FITNESS SCORE is a measure of how well the program is able to find the global minimum of the function, and increasing the number of runs can help to improve this score. However, it's also important to consider the computational cost of the algorithm and to balance this with the need to explore the search space effectively."]}}, "artifacts_json": "{\"stage1_result\": \"Found solution at x=-1.7041, y=0.6775 with value=-1.5187\", \"distance_to_global\": \"0.0005\", \"solution_quality\": \"Distance < 0.5: Very close\", \"convergence_info\": \"Converged in 10 trials with 10 successes\", \"best_position\": \"Final position: x=-1.7041, y=0.6775\", \"average_distance_to_global\": \"0.0005\", \"search_efficiency\": \"Success rate: 100.00%\"}", "artifact_dir": null, "embedding": null}