{"id": "f7aee1c9-8695-49f5-bd14-e5c0ca0956b8", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-0.1, 0.1)\n        y_new = best_y + np.random.uniform(-0.1, 0.1)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    # Perform an additional local search with a smaller step size\n    local_search_iterations_small_step = 50\n    local_search_step_size_small = 0.001\n    for _ in range(local_search_iterations_small_step):\n        x_new = best_x + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        y_new = best_y + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "a237d501-00fd-43b0-9559-9e4fa04ff38b", "generation": 6, "timestamp": 1762987641.9857142, "iteration_found": 71, "metrics": {"runs_successfully": 1.0, "value_score": 0.9996859395135487, "distance_score": 0.9995011308416932, "combined_score": 1.4995399635139235, "reliability_score": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.9996859395135509, "distance_score": 0.9995011267605152, "combined_score": 1.499539961677395, "reliability_score": 1.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms.", "user": "# Current Program Information\n- Fitness: 1.4995\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness improved: 1.4995 \u2192 1.4995\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stage1_result\n```\nFound solution at x=-1.7041, y=0.6775 with value=-1.5187\n```\n\n### distance_to_global\n```\n0.0005\n```\n\n### solution_quality\n```\nDistance < 0.5: Very close\n```\n\n### convergence_info\n```\nConverged in 10 trials with 10 successes\n```\n\n### best_position\n```\nFinal position: x=-1.7041, y=0.6775\n```\n\n### average_distance_to_global\n```\n0.0005\n```\n\n### search_efficiency\n```\nSuccess rate: 100.00%\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9995, combined_score: 1.4995, reliability_score: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-0.1, 0.1)\n        y_new = best_y + np.random.uniform(-0.1, 0.1)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n### Program 2 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max: Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Perform multiple restarts with a smaller number of trials and a smaller step size for local search\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    local_search_step_size = 0.01\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-local_search_step_size, local_search_step_size)\n        y_new = best_y + np.random.uniform(-local_search_step_size, local_search_step_size)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    # Perform an additional local search with a smaller step size\n    local_search_iterations_small_step = 50\n    local_search_step_size_small = 0.001\n    for _ in range(local_search_iterations_small_step):\n        x_new = best_x + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        y_new = best_y + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n### Program 3 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 5\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9995), Performs well on combined_score (1.4995), Performs well on reliability_score (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 5\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n### Program D2 (Score: 1.4995)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-0.1, 0.1)\n        y_new = best_y + np.random.uniform(-0.1, 0.1)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 1.4995, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 5\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (1.000)\n\n### Inspiration 2 (Score: 1.4995, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 5\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (1.000)\n\n### Inspiration 3 (Score: 1.4995, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-0.1, 0.1)\n        y_new = best_y + np.random.uniform(-0.1, 0.1)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (1.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max: Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Perform multiple restarts with a smaller number of trials and a smaller step size for local search\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    local_search_step_size = 0.01\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-local_search_step_size, local_search_step_size)\n        y_new = best_y + np.random.uniform(-local_search_step_size, local_search_step_size)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    # Perform an additional local search with a smaller step size\n    local_search_iterations_small_step = 50\n    local_search_step_size_small = 0.001\n    for _ in range(local_search_iterations_small_step):\n        x_new = best_x + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        y_new = best_y + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\nimport random\nfrom scipy.optimize import differential_evolution\n\ndef evaluate_function(x):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x[0]) * np.cos(x[1]) + np.sin(x[0] * x[1]) + (x[0]**2 + x[1]**2) / 20\n\n\ndef search_algorithm(bounds=((-5, 5), (-5, 5)), iterations=1000):\n    \"\"\"\n    A differential evolution algorithm to find the global minimum.\n\n    Args:\n        bounds: Bounds for the search space (min, max)\n        iterations: Number of iterations to run\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    # Run the differential evolution algorithm with multiple restarts\n    # to improve the chances of finding the global minimum\n    num_restarts = 10\n    results = []\n    for _ in range(num_restarts):\n        result = differential_evolution(evaluate_function, bounds, maxiter=iterations)\n        results.append(result)\n\n    # Combine the results and select the best one\n    best_result = min(results, key=lambda result: result.fun)\n    best_x, best_y = best_result.x\n    best_value = best_result.fun\n\n    # Perform local search around the best solution to refine the result\n    local_search_iterations = 100\n    for _ in range(local_search_iterations):\n        x_new = best_x + np.random.uniform(-0.1, 0.1)\n        y_new = best_y + np.random.uniform(-0.1, 0.1)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    # Perform an additional local search with a smaller step size\n    local_search_iterations_small_step = 50\n    local_search_step_size_small = 0.001\n    for _ in range(local_search_iterations_small_step):\n        x_new = best_x + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        y_new = best_y + np.random.uniform(-local_search_step_size_small, local_search_step_size_small)\n        x_new = max(bounds[0][0], min(x_new, bounds[0][1]))\n        y_new = max(bounds[1][0], min(y_new, bounds[1][1]))\n        value_new = evaluate_function((x_new, y_new))\n        if value_new < best_value:\n            best_x, best_y, best_value = x_new, y_new, value_new\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    # Run the search\n    x, y, value = run_search()\n\n    # Print the result\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\nThe final answer is: \n\nFound minimum at (-1.7041, 0.6775) with value -1.5187"]}}, "artifacts_json": "{\"stage1_result\": \"Found solution at x=-1.7041, y=0.6775 with value=-1.5187\", \"distance_to_global\": \"0.0005\", \"solution_quality\": \"Distance < 0.5: Very close\", \"convergence_info\": \"Converged in 10 trials with 10 successes\", \"best_position\": \"Final position: x=-1.7041, y=0.6775\", \"average_distance_to_global\": \"0.0005\", \"search_efficiency\": \"Success rate: 100.00%\"}", "artifact_dir": null, "embedding": null}