{"id": "cfd31947-5fe8-4c9b-af10-8b10e50db62b", "code": "# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.995  # Adjusted cooling rate for slower temperature decrease\n    mutation_rate = 0.15  # Increased mutation rate for more exploration\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001 or _ == iterations - 1:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")", "language": "python", "parent_id": "f2b62ce4-2225-49eb-9072-1b4d27456cfb", "generation": 2, "timestamp": 1763418170.942305, "iteration_found": 58, "metrics": {"runs_successfully": 1.0, "value_score": 0.8905386692271956, "distance_score": 0.49538718816967847, "combined_score": 0.9526625892774014, "reliability_score": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"runs_successfully": 1.0, "value_score": 0.9996837564423203, "distance_score": 0.9988662633196013, "combined_score": 1.499252635825561, "reliability_score": 1.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert programmer specializing in optimization algorithms. Your task is to improve a function minimization algorithm to find the global minimum of a complex function with many local minima. The function is f(x, y) = sin(x) * cos(y) + sin(x*y) + (x^2 + y^2)/20. Focus on improving the search_algorithm function to reliably find the global minimum, escaping local minima that might trap simple algorithms.", "user": "# Current Program Information\n- Fitness: 1.4993\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness improved: 1.2734 \u2192 1.4993\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stage1_result\n```\nFound solution at x=-1.7041, y=0.6775 with value=-1.5187\n```\n\n### distance_to_global\n```\n0.0005\n```\n\n### solution_quality\n```\nDistance < 0.5: Very close\n```\n\n### convergence_info\n```\nConverged in 10 trials with 10 successes\n```\n\n### best_position\n```\nFinal position: x=-1.7041, y=0.6775\n```\n\n### average_distance_to_global\n```\n0.0011\n```\n\n### search_efficiency\n```\nSuccess rate: 100.00%\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9715, distance_score: 0.8168, combined_score: 1.2734\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: runs_successfully: 1.0000, value_score: 0.9900, distance_score: 0.7146, combined_score: 1.3640, reliability_score: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: runs_successfully: 1.0000, value_score: 0.9997, distance_score: 0.9989, combined_score: 1.4993, reliability_score: 1.0000\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.4993)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing and genetic algorithm to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 100\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.argmin(values)\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                offspring[i] = (parent1 + parent2) / 2\n\n        # Mutate\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.uniform(-1, 1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Select best\n        idx = np.argmin(values)\n        if values[idx] < best_value:\n            best_value = values[idx]\n            best_x, best_y = offspring[idx]\n\n        # Replace population\n        population = offspring\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9997), Performs well on distance_score (0.9989), Performs well on combined_score (1.4993), Performs well on reliability_score (1.0000)\n\n### Program 2 (Score: 1.3640)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 100\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.argmin(values)\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                offspring[i] = (parent1 + parent2) / 2\n\n        # Mutate\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.uniform(-1, 1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9900), Performs well on distance_score (0.7146), Performs well on combined_score (1.3640), Performs well on reliability_score (1.0000)\n\n### Program 3 (Score: 1.2734)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on value_score (0.9715), Performs well on distance_score (0.8168), Performs well on combined_score (1.2734)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8188)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001 or _ == iterations - 1:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n### Program D2 (Score: 1.1332)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to value_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4254, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 250  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.995  # Adjusted cooling rate for slower temperature decrease\n    mutation_rate = 0.15  # Increased mutation rate for more exploration\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001 or _ == iterations - 1:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Alternative distance_score approach\n\n### Inspiration 2 (Score: 1.3640, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 100\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.argmin(values)\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                offspring[i] = (parent1 + parent2) / 2\n\n        # Mutate\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.uniform(-1, 1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (0.990)\n\n### Inspiration 3 (Score: 1.2734, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\nUnique approach: Modification: Full rewrite, Excellent runs_successfully (1.000), Excellent value_score (0.971)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing and genetic algorithm to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 100\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.99\n    mutation_rate = 0.1\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.argmin(values)\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                offspring[i] = (parent1 + parent2) / 2\n\n        # Mutate\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.uniform(-1, 1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Select best\n        idx = np.argmin(values)\n        if values[idx] < best_value:\n            best_value = values[idx]\n            best_x, best_y = offspring[idx]\n\n        # Replace population\n        population = offspring\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Function minimization example for OpenEvolve\"\"\"\nimport numpy as np\n\n\ndef search_algorithm(iterations=1000, bounds=(-5, 5)):\n    \"\"\"\n    An improved random search algorithm with simulated annealing, genetic algorithm, \n    and particle swarm optimization to escape local minima.\n\n    Args:\n        iterations: Number of iterations to run\n        bounds: Bounds for the search space (min, max)\n\n    Returns:\n        Tuple of (best_x, best_y, best_value)\n    \"\"\"\n    population_size = 200  # Increased population size for better exploration\n    population = np.random.uniform(bounds[0], bounds[1], size=(population_size, 2))\n    best_x, best_y = population[0]\n    best_value = evaluate_function(best_x, best_y)\n    temperature = 1.0\n    cooling_rate = 0.995  # Adjusted cooling rate for slower temperature decrease\n    mutation_rate = 0.15  # Increased mutation rate for more exploration\n    particle_velocity = np.zeros_like(population)\n    particle_best_x = np.copy(population)\n    particle_best_y = np.copy(population)\n    particle_best_value = np.array([evaluate_function(x, y) for x, y in population])\n\n    for _ in range(iterations):\n        # Evaluate population\n        values = np.array([evaluate_function(x, y) for x, y in population])\n\n        # Select parents using tournament selection\n        parents = np.array([population[np.argmin(values)]])\n        while len(parents) < population_size // 2:\n            idx = np.random.choice(len(values), size=5, replace=False)\n            idx = idx[np.argmin(values[idx])]\n            parents = np.vstack((parents, population[idx]))\n            values[idx] = np.inf\n\n        # Crossover using BLX-alpha\n        offspring = np.zeros_like(population)\n        for i in range(population_size):\n            if i < population_size // 2:\n                offspring[i] = parents[i % len(parents)]\n            else:\n                parent1, parent2 = parents[np.random.choice(len(parents), size=2, replace=False)]\n                alpha = 0.5\n                offspring[i] = (parent1 + parent2) / 2 + alpha * (parent1 - parent2)\n\n        # Mutate using Gaussian noise\n        for i in range(population_size):\n            if np.random.rand() < mutation_rate:\n                offspring[i] += np.random.normal(0, 0.1, size=2)\n\n        # Ensure bounds are respected\n        offspring = np.clip(offspring, bounds[0], bounds[1])\n\n        # Evaluate offspring\n        values = np.array([evaluate_function(x, y) for x, y in offspring])\n\n        # Update particle best\n        for i in range(population_size):\n            if values[i] < particle_best_value[i]:\n                particle_best_value[i] = values[i]\n                particle_best_x[i] = offspring[i]\n                particle_best_y[i] = offspring[i]\n\n        # Update global best\n        idx = np.argmin(particle_best_value)\n        if particle_best_value[idx] < best_value:\n            best_value = particle_best_value[idx]\n            best_x, best_y = particle_best_x[idx]\n\n        # Update particle velocity\n        particle_velocity = 0.5 * particle_velocity + 1.0 * (particle_best_x - population) + 1.0 * (np.array([best_x, best_y]) - population)\n\n        # Update population\n        population = population + particle_velocity\n\n        # Cool down temperature\n        temperature *= cooling_rate\n\n        # Early termination condition\n        if best_value < 0.001 or _ == iterations - 1:\n            break\n\n    return best_x, best_y, best_value\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef evaluate_function(x, y):\n    \"\"\"The complex function we're trying to minimize\"\"\"\n    return np.sin(x) * np.cos(y) + np.sin(x * y) + (x**2 + y**2) / 20\n\n\ndef run_search():\n    x, y, value = search_algorithm()\n    return x, y, value\n\n\nif __name__ == \"__main__\":\n    x, y, value = run_search()\n    print(f\"Found minimum at ({x}, {y}) with value {value}\")\n```"]}}, "artifacts_json": "{\"stage1_result\": \"Found solution at x=-1.7501, y=0.7632 with value=-1.5013\", \"distance_to_global\": \"0.0969\", \"solution_quality\": \"Distance < 0.5: Very close\", \"convergence_info\": \"Converged in 10 trials with 10 successes\", \"best_position\": \"Final position: x=-1.5606, y=0.6577\", \"average_distance_to_global\": \"1.0186\", \"search_efficiency\": \"Success rate: 100.00%\"}", "artifact_dir": null, "embedding": null}